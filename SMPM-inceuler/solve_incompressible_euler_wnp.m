function [ux uz rho t] = solve_incompressible_euler( n, mx, mz, x, z, ux0, uz0, rhoi, rhob, max_dt, t_final, tau, alpha_D, alpha_E )
% [ux uz rho t] = solve_incompressible_euler( n, mx, mz, x, z, ux0, uz0, rho0, rhob, dt, t_final, ptype, tau );
%
%  Solves the incompressible Euler equations with a spectral multidomain
%  penalty method model on a cartesian (plaid) grid with an active density
%  and gravity.
%
%  Takes 12 arguments:
%
%     n, mx, mz      - grid discretization constants.
%     x, z           - grid generated by smpm_build_cartesian_grid.
%     ux0, uz0, rho0 - initial conditions, grid functions on x, z.
%     rhob           - boussinesq density, or 0.0 if there is no background stratification.
%     dt, t_final    - maximum timestep, final time.
%     tau            - penalty multiplicative coefficient.
%     alpha_D        - regularization coefficient multiplying D^TD.
%     alpha_E        - regularization coefficient multiplying E^TE.
%
%  Returns 3 arguments:
%
%     ux, uz, rho    - solution of the incompressible Euler equations.
%     t              - time.
%
%  7 July 2015
%  Sumedh Joshi
%  Cornell University

   % Set some constants / inputs.
   Lx      = max(x) - min(x);
   Lz      = max(z) - min(z);
   rho0    = 1000.0;
   g       = 9.8;
   CFL_MAX = 0.25;

   % Set the flag for type of projection to play nice with legacy code.
   ptype = 'postnormal';

   % Build the operator matrices.
   r = n * n * mx * mz;
   [Dx Dz E0x E0z E1x E1z B0x B0z Bnx Bnz] = smpm_assemble_2D_cartesian( n, mx, mz, Lx, Lz );
   B1 = Bnx + Bnz;

   % Do some argument handling.
   if length( rhob ) == 1
      rhob = 0 * rhoi;
   end

   % Get a penalty coefficient.
   hx = Lx / mx;
   hz = Lz / mx;

   dt = max_dt;

   % Build the Laplacian.
   DG = Dx * Dx + Dz * Dz;

   % Build a filter.
   [xi, w, junk] = lglnodes( n-1 );
   xi            = flipud( xi )';
   F = build_filter( n, xi, w, 16.0 );

%   % XXX: use the apply filter function to get the actual filtering action matrix.
%   T = zeros( r, r );
%   for ii = 1:r
%      %iiux  = apply_filter( n, mx, mz, iiux,  F );
%      iie = zeros( r, 1 );
%      iie( ii ) = 1.0;
%      T(:, ii ) = apply_filter( n, mx, mz, iie, F );
%   end
%   keyboard;

   % Get a penalty coefficient.

   % Build the Poisson matrix and its null space.
   if strcmp( ptype, 'poisson' ) || strcmp( ptype, 'postproject' ) || strcmp( ptype, 'postnull' ) || strcmp( ptype, 'postnormal' )
      omega = 2.0 / ( n - 1 ) / n;
      kappa = omega;
      pen    = 1.0 / omega * ( 1.0 + ( 2 * kappa ) - ( 2 * sqrt( kappa^2 + kappa ) ) );
      pen_bc = 1.0 / omega^2;
      EL = tau * pen * ( 2 / hx ) * E0x + tau * pen * ( 2 / hz ) * E0z + ( tau * pen * 2 / hx ) * E1x + ( tau * pen * 2 / hz ) * E1z + ...
                 pen_bc * 2 / hx * Bnx + pen_bc * 2 / hz * Bnz;
      L = DG - EL;
      [u0, junk, junk] = svds( L, 1, 0 );
   end

   % Build the divergence and gradient operators.

      % Divergence.
      r  = n * n * mx * mz;
      D = sparse( r, 2 * r );
      D(:,1:r)     = Dx;
      D(:,r+1:end) = Dz;

      % Gradient.
      G = sparse( 2 * r, r );
      G( 1:r, : )     = Dx;
      G( r+1:end, : ) = Dz;

   % Compute the derivative of the density stratification.
   rhob_z = Dz * rhob;

   % Build the vector C0 continuity operator.
   E_C0 = [ (E0x + E0z + E1x + E1z + B0x) zeros(r,r); zeros(r,r) (E0x + E0z + E1x + E1z + B0z) ];

   % Set up the twice-penalized normal equatinos for a direct method if asked to do so.
   if strcmp( ptype, 'normal' ) || strcmp( ptype, 'postnormal' )

      fprintf('Factoring normal equations. \n' );
      L1 = 1; L2 = alpha_E; L3 = alpha_D;
      T2 = L1 * eye( 2*r, 2*r ) + L2 * E_C0'*E_C0 + L3 * D'*D ;
      [LT UT] = lu(T2);

   end

   % Set some time-stepping parameters.
   min_dx  = z(2) - z(1);  % XXX: Only works for cartesian grids.
   c       = sqrt(max( ux0.^2 + uz0.^2 ));
   dt      = min( min_dx / c / 10, max_dt );
   t(1)    = 0.0;

   % Allocate arrays to store the field variables.
   ux   = zeros( r, 1 );
   uz   = zeros( r, 1 );
   rho  = zeros( r, 1 );

   % Begin time-stepping.
   ux(  :, 1 ) = ux0;
   uz(  :, 1 ) = uz0;
   rho( :, 1 ) = rhoi;
   uzu = uz;
   uxu = ux;
   Gpx = 0 * ux(: ,1);
   Gpz = 0 * uz(:, 1);
   while t(end) < t_final

      % Apply the non-linear advection operator.
      Aux = apply_smpm_advection( ux(:,end), Dx, Dz, ux(:,end), uz(:,end), Lx, Lz, n, mx, mz );
      Auz = apply_smpm_advection( uz(:,end), Dx, Dz, ux(:,end), uz(:,end), Lx, Lz, n, mx, mz );

      % Apply the advective operator to the density.
      Arho = apply_smpm_advection( rho(:,end), Dx, Dz, ux(:,end), uz(:,end), Lx, Lz, n, mx, mz );
      Arho = Arho - uz(:, end) .* rhob_z;

      % Update the current velocity.
      iiux = ux(:,end) + dt * Aux;
      iiuz = uz(:,end) + dt * Auz - dt * g * rho(:,end) ./ ( rho0 + rhob ) ;

      % Apply a filter.
      %iiux  = apply_filter( n, mx, mz, iiux,  F );
      %iiuz  = apply_filter( n, mx, mz, iiuz,  F );

      % Update the current density.
      iirho = rho(:,end) + dt * Arho;

      uxu  = [uxu iiux];
      uzu  = [uzu iiuz];

      % Project onto the weakly divergence-free weakly continuous basis.

      % Set up a right-hand-side.
      b = -D * [ iiux; iiuz ] / dt;
      b = b - u0 * u0' * b;

      % Solve the Poisson equation.
      p = L \ b;

      % Update the current velocities.
      Gp = G * p;
      iiux = iiux + dt * Gp(1:r);
      iiuz = iiuz + dt * Gp(r+1:end);

      % Set up a right-hand-side vector.
      b = [ iiux; iiuz ];

      % Print some diagnostic information.
      divu = norm( D*b );
      conu = norm( E_C0 * b );

      % Solve the normal equations.
      iiu =   UT \ ( LT \ b );
      iiux = iiu(1:r);
      iiuz = iiu(r+1:end);

      fprintf( [ 'div(u) reduced from ', num2str( divu ), ' to ', num2str( norm(D*[iiux;iiuz] ) ) ' \n' ] );
      fprintf( [ 'con(u) reduced from ', num2str( conu ), ' to ', num2str( norm(E_C0*[iiux;iiuz] ) )  ' \n' ] );
      fprintf( [ 'norm(u) changed by  ', num2str( norm(  [iiux;iiuz] )  - norm(b) ), ' \n ' ]);

      % Print out a CFL number.
      umax  = sqrt( max( iiux.^2 + iiuz.^2 ) );
      iiCFL = sqrt( max( iiux.^2 + iiuz.^2 ) ) * dt / min_dx;
      fprintf( [ 'Time :' num2str(t(end)) ', CFL number:', num2str( iiCFL ) '\n'] );

      % Append the current time-step data.
      ux  = [ux iiux];
      uz  = [uz iiuz];
      rho = [rho iirho];

      % Set a new time-step.
      dt = CFL_MAX * min_dx / umax;
      if ( dt > max_dt)
         dt = max_dt;
      end
      t  = [ t; t(end) + dt ];
      fprintf( ['   New Time-Step: ', num2str(dt) '\n'] );

      if dt < 1.0e-3
         fprintf( 'Simulation has gone unstable. Exiting.\n' );
         return;
      end

   end

end
